'use strict';
const __root = require('app-root-path').path;
const path = require('path');
/** @type {UtilsConstructor} - Utils Class static members. */
const Utils = require(path.join(__root, 'cls', 'utils.cjs'));

const fs = require('fs');

const { ipcRegistry, ipcDataRegistry, typeDocs } = require('../ipcRegistry.cjs');

/**
 * Normalize the IPC configuration.
 * @param {*} config 
 * @returns 
 */
const normalize = (config) =>
  typeof config === 'boolean' ? { log: config } : config;

const methodTypes = new Map();
const callbackTypes = new Map();
const lines = [];

lines.push('// Auto-generated by generate-global-dts.cjs on '.concat(new Date().toISOString()));
lines.push('// Do not edit this file directly. Edit the source files instead.');
lines.push('//    ipcRegistry.cjs');
lines.push('export {};');
lines.push('');
lines.push('declare global {');
lines.push('  interface Window {');
lines.push(...typeDocs.get('api').split('\n'));
lines.push('    api: {');

// ðŸ” Main API methods / Return values
for (const [channel, rawConfig] of Object.entries(ipcDataRegistry)) {
  const config = normalize(rawConfig);
  const methodName = Utils.kebabToCamel(channel);
  const returnType = config.requiresResponse
    ? config.returnType || 'any'
    : 'void';

  if (config.hasOwnProperty('type') && config.type !== undefined) {
    methodTypes.set(methodName, 
      { type: config.type, parameterType: config.parameterType, parameters: config.parameters, returnType: returnType });

    lines.push(`      ${methodName}: ${config.type};`);
  } else {
    lines.push(`      ${methodName}: (...args: IpcApiArgs) => IpcApiResponse<${returnType}>;`);
  }
}
lines.push('');

// ðŸ” Main API methods / Don't return values
for (const [channel, rawConfig] of Object.entries(ipcRegistry)) {
  const config = normalize(rawConfig);
  const methodName = Utils.kebabToCamel(channel);
  const returnType = config.requiresResponse
    ? config.returnType || 'any'
    : 'void';

  if (config.hasOwnProperty('type') && config.type !== undefined) {
    methodTypes.set(methodName, 
      { type: config.type, parameterType: config.parameterType, parameters: config.parameters, returnType: returnType });

    lines.push(`      ${methodName}: ${config.type};`);
  } else {
    lines.push(`      ${methodName}: (...args: IpcApiArgs) => IpcApiResponse<${returnType}>;`);
  }
}
lines.push('');

// ðŸ” Listener methods for ipcRegistry only
for (const [channel, rawConfig] of Object.entries(ipcRegistry)) {
  const config = normalize(rawConfig);
  const baseName = Utils.kebabToCamel(channel, true);
  const cb = config.callbackType ? config.name.concat('Callback') : 'IpcCallback';

  callbackTypes.set(cb, config.callbackType);

  lines.push(`      on${baseName}Done: (callback: ${cb}) => () => void;`);
  lines.push(`      on${baseName}Failed: (callback: ${cb}) => () => void;`);
}

// ðŸ” One-off methods
lines.push('');
lines.push('      openReviewWindow: () => void;');
lines.push('      toggleDevTools: () => void;');

lines.push('    };');
lines.push('  }');

/** @type {[string, boolean][]} */
const callBackTypesEntries = Array.from(callbackTypes.entries());

// If you need both key and value from the Map, you can use callBackTypesEntries
// Example: iterate and log both key and value
// for (const [cbType, value] of callBackTypesEntries) {
//   console.log(cbType, value);
// }

// ðŸ” Named callback interfaces
for (const [cbType, value] of callBackTypesEntries) {
  lines.push('');
  if (typeDocs.has(cbType)) {
    lines.push(...typeDocs.get(cbType).split('\n'));
  }
  lines.push(`  type ${cbType} = ${value ? value : '(...args: IpcApiArgs) => void'};`);
}

/** @type {[string, { type: string, parameterType: string, parameters: string, returnType: string }][]} */
const methodTypesEntries = Array.from(methodTypes.entries());

// ðŸ” Named method interfaces
for (const [_, value] of methodTypesEntries) {
  const { type, parameterType, parameters, returnType } = value;

  if (parameterType) {
    lines.push('');
    if (typeDocs.has(parameterType)) {
      lines.push(...typeDocs.get(parameterType).split('\n'));
    }
    lines.push(`  type ${parameterType} = ${parameters};`);
  }

  if (type) {
    lines.push('');
    if (typeDocs.has(type)) {
      lines.push(...typeDocs.get(type).split('\n'));
    }
    if (parameterType) {
      lines.push(`  type ${type} = (...args: ${parameterType}) => IpcApiResponse<${returnType}>;`);
    } else {
      lines.push(`  type ${type} = (...args: IpcApiArgs) => IpcApiResponse<${returnType}>;`);
    }
  }
}

// ðŸ” IpcApiArgs, IpcConfig, IpcApi, IpcCallback
lines.push('');
lines.push(...typeDocs.get('IpcConfig').split('\n'));
lines.push('  interface IpcConfig {');
lines.push('    log?: boolean;');
lines.push('    name?: MangaResolveMethodName;');
lines.push('    type?: string;');
lines.push('    parameterType?: string;');
lines.push('    parameters?: string;');
lines.push('    validateArgs?: (...args: IpcApiArgs) => boolean;');
lines.push('    requiresResponse?: boolean;');
lines.push('    returnType?: string;');
lines.push('    callbackType?: string;');
lines.push('  }');

lines.push('');
lines.push(...typeDocs.get('IpcApi').split('\n'));
lines.push('  interface IpcApi {');
lines.push('    [key: string]: (...args: any[]) => any;');
lines.push('  }');

lines.push('');
lines.push(...typeDocs.get('IpcApiArgs').split('\n'));
lines.push('  type IpcApiArgs = unknown[];');

lines.push('');
lines.push(...typeDocs.get('IpcApiResponse').split('\n'));
lines.push('  type IpcApiResponse<T> = Promise<T>;');

lines.push('}');

const fd = fs.openSync(path.resolve(__dirname, '../types/global.d.ts'), 'w', 0o666 | fs.constants.O_RDWR | fs.constants.O_CREAT | fs.constants.O_TRUNC);
fs.writeSync(fd, lines.join('\n'), 0, 'utf8');
fs.closeSync(fd);
console.log('âœ… global.d.ts generated from registry metadata.');